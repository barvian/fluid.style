const to10thFmt = new Intl.NumberFormat('en-US', {
    maximumFractionDigits: 1,
    useGrouping: false
})
const to100thFmt = new Intl.NumberFormat('en-US', {
    maximumFractionDigits: 2,
    useGrouping: false
})
const to1000thFmt = new Intl.NumberFormat('en-US', {
    maximumFractionDigits: 3,
    useGrouping: false
})

export const UNITS = ['rem', 'px'] as const
export type Unit = typeof UNITS[number]

export type Range = [number, number]

export const clamp = (min: number, val: number, max: number) => Math.min(Math.max(min, val), max)

export const to10th = to10thFmt.format
export const to100th = to100thFmt.format
export const to1000th = to1000thFmt.format

export const inRange = (val: number, range?: Range) => range && (range[0] < val && val < range[1])

export function compute({ min, max, minBP, maxBP, checkSC144 = false }: { min: number, max: number, minBP: number, maxBP: number, checkSC144: boolean }) {
    if (minBP > maxBP) {
        // need to flip because our checks assume minBP < maxBP
        const oldMinScreen = minBP
        minBP = maxBP
        maxBP = oldMinScreen
        
        const oldmin = min
        min = max
        max = oldmin
    }
    const slope = (max - min) / (maxBP - minBP)
    const intercept = min - (minBP * slope)

    if (!checkSC144) return {
        slope,
        intercept
    }

    const lh = (5*min - 2*intercept) / (2*slope)
    const rh = (5*intercept - 2*max) / (-1*slope)
    const lh2 = 3*intercept / slope

    // this assumes minBP < maxBP, hence the flip above
    // These were generated by creating piecewise functions for z5 (the font at 500% zoom in Chrome/Firefox)
    // and 2*z1 (2*the font at 100% zoom; the WCAG requirement), then solving for
    // z5 < 2*z1
    let failRange: number[] | undefined = []
    if (maxBP < 5*minBP) {
        if (minBP < lh && lh < maxBP) {
            failRange.push(Math.max(lh, minBP), maxBP)
        }
        if (5*min < 2*max) {
            failRange.push(maxBP, 5*minBP)
        }
        if (5*minBP < rh && rh < 5*maxBP) {
            failRange.push(5*minBP, Math.min(rh, 5*maxBP))
        }
    } else {
        if (minBP < lh && lh < 5*minBP) {
            failRange.push(Math.max(lh, minBP), 5*minBP)
        }
        if (5*minBP < lh2 && lh2 < maxBP) {
            failRange.push(Math.max(lh2, 5*minBP), maxBP)
        }
        if (maxBP < rh && rh < 5*maxBP) {
            failRange.push(maxBP, Math.min(rh, 5*maxBP))
        }
    }

    // Clean up range
    if (failRange.length) {
        failRange = [failRange[0], failRange[failRange.length-1]]
        if (Math.abs(failRange[1] - failRange[0]) < 0.1) failRange = undefined // rounding errors, ignore
    }

    return {
        slope,
        intercept,
        failRange: failRange as Range
    }
}